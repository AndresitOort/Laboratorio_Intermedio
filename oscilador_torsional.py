# -*- coding: utf-8 -*-
"""Oscilador_torsional.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RjKI7qvWJZ3HPDbBXOIL8gw9na58aMxH
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# Datos
theta = np.array([
    0.02,0.04,0.06,0.08,0.1,0.12,0.14,0.16,0.18,0.2,0.22,0.24,0.26,0.28,0.3,0.32,
    0.34,0.36,0.38,0.4,0.42,0.44,0.46,0.48,0.5,0.52,0.54,0.56,0.58,0.6,0.62,0.64,
    0.66,0.68,0.7,0.72,0.74,0.76
])
vpp = np.array([
    1.24,1.9,2.16,3.4,4.36,5.16,5.8,6.72,8.16,8.4,9.4,9.68,10.6,11.2,12,13.1,
    13.7,14.1,15.8,16.6,16.8,18.2,18.8,19.8,20.2,21.2,22.2,22.2,23.4,24.2,25.2,25.8,
    27,27.4,28.6,29,29.4,30.8
])

# Incertidumbres conocidas
theta_err = 0.01
vpp_err = 0.01

# Modelo lineal
def f(x, m, b):
    return m*x + b

# Ajuste con incertidumbre de los parámetros
popt, pcov = curve_fit(f, theta, vpp, sigma=np.full_like(vpp, vpp_err), absolute_sigma=True)
m, b = popt
m_err, b_err = np.sqrt(np.diag(pcov))

# Función para redondear con 1 cifra significativa en la incertidumbre
def format_with_error(value, error):
    # 1 cifra significativa en el error
    err_rounded = float(f"{error:.1g}")
    # número de decimales del error
    decimals = -int(np.floor(np.log10(err_rounded)))
    # redondear valor y error con esos decimales
    val_rounded = round(value, decimals)
    err_rounded = round(err_rounded, decimals)
    return val_rounded, err_rounded, decimals

m_val, m_err, _ = format_with_error(m, m_err)
b_val, b_err, _ = format_with_error(b, b_err)

# R^2
resid = vpp - f(theta, m, b)
ss_res = np.sum(resid**2)
ss_tot = np.sum((vpp - np.mean(vpp))**2)
r2 = 1 - ss_res/ss_tot

# Gráfica
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8, 8), sharex=True,
                               gridspec_kw={'height_ratios': [3, 1]})

# Datos con barras de error y ajuste
ax1.errorbar(theta, vpp, xerr=theta_err, yerr=vpp_err, fmt="o", color="blue",
             ecolor="gray", elinewidth=1, capsize=2, label="Datos con error")
ax1.plot(theta, f(theta, m, b), color="red",
         label=(fr"Ajuste lineal:" "\n"
                fr"$y=({m_val}\pm{m_err})x+({b_val}\pm{b_err})$"
                "\n"
                fr"$R^2={r2:.4f}$"))

ax1.legend()
ax1.set_ylabel("V (mV)")
ax1.set_title("Calibración del rotor, (V(mV) vs. $\Delta \\theta$ (rad))")
ax1.grid(False)

# Residuales
ax2.errorbar(theta, resid, fmt="o", color="black",
             ecolor="lightgray", elinewidth=1, capsize=2)
ax2.axhline(0, color="red", linestyle="--")
ax2.set_xlabel(r"$\Delta \theta$ (rad)")
ax2.set_ylabel(r"$V_{exp}-V_{ajuste}$")
ax2.grid(False)

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# -------------------------
# DATOS REALES
# -------------------------
delta_theta = np.array([0.173, 0.313, 0.693, 0.953,
                        -0.227, -0.427, -0.827, -1.707])

tau = np.array([0.01232381, 0.02464762, 0.04929523, 0.09859046,
                0.01232381, 0.02464762, 0.04929523, 0.09859046])

tau_err = np.array([0.000048904, 0.000097808, 0.000195616, 0.000391232,
                    0.000048904, 0.000097808, 0.000195616, 0.000391232])

theta_err = 0.01  # rad (incertidumbre constante en Δθ)

# -------------------------
# FUNCIONES
# -------------------------
def f(x, m, b):
    return m*x + b

def format_with_error(value, error):
    """Devuelve valor ± error con 1 cifra significativa en el error"""
    err_rounded = float(f"{error:.1g}")
    decimals = -int(np.floor(np.log10(err_rounded)))
    val_rounded = round(value, decimals)
    err_rounded = round(err_rounded, decimals)
    return val_rounded, err_rounded

def fit_and_plot(ax1, ax2, x, y, yerr, title):
    # Ajuste
    popt, pcov = curve_fit(f, x, y, sigma=yerr, absolute_sigma=True)
    m, b = popt
    m_err, b_err = np.sqrt(np.diag(pcov))

    # Redondeo formal
    m_val, m_err = format_with_error(m, m_err)
    b_val, b_err = format_with_error(b, b_err)

    # R^2
    resid = y - f(x, m, b)
    ss_res = np.sum(resid**2)
    ss_tot = np.sum((y - np.mean(y))**2)
    r2 = 1 - ss_res/ss_tot

    # Gráfico principal
    ax1.errorbar(x, y, xerr=theta_err, yerr=yerr, fmt="o", color="blue",
                 ecolor="gray", elinewidth=1, capsize=2, label="Datos con error")
    ax1.plot(x, f(x, m, b), color="red",
             label=(fr"Ajuste lineal:" "\n"
                    fr"$y=({m_val}\pm{m_err})x+({b_val}\pm{b_err})$"
                    "\n"
                    fr"$R^2={r2:.4f}$"))
    ax1.legend()
    ax1.set_ylabel(r"$\tau$ (N·m)")
    ax1.set_title(title)
    ax1.grid(False)

    # Residuos
    ax2.errorbar(x, resid, xerr=theta_err, yerr=yerr, fmt="o", color="black",
                 ecolor="lightgray", elinewidth=1, capsize=2)
    ax2.axhline(0, color="red", linestyle="--")
    ax2.set_xlabel(r"$\Delta \theta$ (rad)")
    ax2.set_ylabel(r"$\tau_{exp}-\tau_{ajuste}$")
    ax2.grid(False)

# -------------------------
# SEPARAR POSITIVOS Y NEGATIVOS
# -------------------------
mask_pos = delta_theta > 0
mask_neg = delta_theta < 0

# Gráfica Δθ positivos
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8, 8), sharex=True,
                               gridspec_kw={'height_ratios': [3, 1]})
fit_and_plot(ax1, ax2,
             delta_theta[mask_pos], tau[mask_pos], tau_err[mask_pos],
             " τ vs. Δθ (con Δθ > 0)")
plt.tight_layout()
plt.show()

# Gráfica Δθ negativos
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8, 8), sharex=True,
                               gridspec_kw={'height_ratios': [3, 1]})
fit_and_plot(ax1, ax2,
             delta_theta[mask_neg], tau[mask_neg], tau_err[mask_neg],
             "τ vs. Δθ (con Δθ < 0)")
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# -------------------------
# DATOS REALES
# -------------------------
delta_theta = np.array([0.173, 0.313, 0.693, 0.953,
                        -0.227, -0.427, -0.827, -1.707])

tau = np.array([0.01232381, 0.02464762, 0.04929523, 0.09859046,
                -0.01232381, -0.02464762, -0.04929523, -0.09859046])

tau_err = np.array([0.000048904, 0.000097808, 0.000195616, 0.000391232,
                    0.000048904, 0.000097808, 0.000195616, 0.000391232])

theta_err = 0.01  # rad (incertidumbre constante en Δθ)

# -------------------------
# FUNCIONES
# -------------------------
def f(x, m, b):
    return m*x + b

def format_with_error(value, error):
    """Devuelve valor ± error con 1 cifra significativa en el error"""
    err_rounded = float(f"{error:.1g}")
    decimals = -int(np.floor(np.log10(err_rounded)))
    val_rounded = round(value, decimals)
    err_rounded = round(err_rounded, decimals)
    return val_rounded, err_rounded

# -------------------------
# AJUSTE GLOBAL
# -------------------------
popt, pcov = curve_fit(f, delta_theta, tau, sigma=tau_err, absolute_sigma=True)
m, b = popt
m_err, b_err = np.sqrt(np.diag(pcov))

# Redondeo formal
m_val, m_err = format_with_error(m, m_err)
b_val, b_err = format_with_error(b, b_err)

# R^2
resid = tau - f(delta_theta, m, b)
ss_res = np.sum(resid**2)
ss_tot = np.sum((tau - np.mean(tau))**2)
r2 = 1 - ss_res/ss_tot

# -------------------------
# GRÁFICO CON RESIDUOS
# -------------------------
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8, 8), sharex=True,
                               gridspec_kw={'height_ratios': [3, 1]})

# Datos con errores
ax1.errorbar(delta_theta, tau, xerr=theta_err, yerr=tau_err,
             fmt="o", color="blue", ecolor="gray",
             elinewidth=1, capsize=2, label="Datos con error")

# Ajuste lineal
ax1.plot(delta_theta, f(delta_theta, m, b), color="red",
         label=(fr"Ajuste lineal:" "\n"
                fr"$y=({m_val}\pm{m_err})x+({b_val}\pm{b_err})$"
                "\n"
                fr"$R^2={r2:.4f}$"))
ax1.legend()
ax1.set_ylabel(r"$\tau$ (N·m)")
ax1.set_title(r"$\tau$ vs. $\Delta \theta$ (todos los datos)")
ax1.grid(False)

# Residuos
ax2.errorbar(delta_theta, resid, xerr=theta_err, yerr=tau_err,
             fmt="o", color="black", ecolor="lightgray",
             elinewidth=1, capsize=2)
ax2.axhline(0, color="red", linestyle="--")
ax2.set_xlabel(r"$\Delta \theta$ (rad)")
ax2.set_ylabel(r"$\tau_{exp}-\tau_{ajuste}$")
ax2.grid(False)

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# -------------------------
# DATOS
# -------------------------
masas = np.array([0,1,2,3,4,5,6,7,8])
T = np.array([1.15,1.24,1.32,1.39,1.45,1.53,1.56,1.62,1.69])
T2 = np.array([1.3225,1.5376,1.7424,1.9321,2.1025,2.3409,2.4336,2.6244,2.8561])

# Incertidumbre en T (s)
dT = 0.01
# Propagación al cuadrado: Δ(T^2) = 2*T*ΔT
dT2 = 2 * T * dT

# -------------------------
# FUNCIONES
# -------------------------
def f(x, m, b):
    return m*x + b

def format_with_error(value, error):
    """Devuelve valor ± error con 1 cifra significativa en el error"""
    err_rounded = float(f"{error:.1g}")
    decimals = -int(np.floor(np.log10(err_rounded)))
    val_rounded = round(value, decimals)
    err_rounded = round(err_rounded, decimals)
    return val_rounded, err_rounded

# -------------------------
# AJUSTE LINEAL
# -------------------------
popt, pcov = curve_fit(f, masas, T2, sigma=dT2, absolute_sigma=True)
m, b = popt
m_err, b_err = np.sqrt(np.diag(pcov))

# Redondeo formal
m_val, m_err = format_with_error(m, m_err)
b_val, b_err = format_with_error(b, b_err)

# R^2
resid = T2 - f(masas, m, b)
ss_res = np.sum(resid**2)
ss_tot = np.sum((T2 - np.mean(T2))**2)
r2 = 1 - ss_res/ss_tot

# -------------------------
# GRÁFICAS
# -------------------------
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8, 8), sharex=True,
                               gridspec_kw={'height_ratios': [3, 1]})

# Principal
ax1.errorbar(masas, T2, yerr=dT2, fmt="o", color="blue",
             ecolor="gray", capsize=3, label="Datos con error")
ax1.plot(masas, f(masas, m, b), "r-",
         label=(fr"Ajuste lineal:" "\n"
                fr"$y=({m_val}\pm{m_err})x+({b_val}\pm{b_err})$"
                "\n"
                fr"$R^2={r2:.4f}$"))
ax1.legend()
ax1.set_ylabel(r"$T^2$ (s$^2$)")
ax1.set_title("T² vs número de masas")
ax1.grid(False)

# Residuos
ax2.errorbar(masas, resid, fmt="o", color="black",
             ecolor="lightgray", capsize=3)
ax2.axhline(0, color="red", linestyle="--")
ax2.set_xlabel("Número de masas")
ax2.set_ylabel("Residuos")
ax2.grid(False)

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# -------------------------
# DATOS
# -------------------------
theta = np.array([-0.147,-0.287,-0.387,-0.507,-0.587,-0.667,-0.727,-0.787,-0.847,-0.887,
                   0.133,0.253,0.373,0.473,0.573,0.653,0.713,0.793,0.833,0.873])

corriente = np.array([-0.02,-0.04,-0.06,-0.08,-0.1,-0.12,-0.14,-0.16,-0.18,-0.2,
                       0.02,0.04,0.06,0.08,0.1,0.12,0.14,0.161,0.18,0.2])

# Incertidumbres
dI = 0.01   # corriente (mA)
dTheta = 0.01  # rad

# -------------------------
# FUNCIONES
# -------------------------
def f(x, m, b):
    return m*x + b

def format_with_error(value, error):
    """Devuelve valor ± error con 1 cifra significativa en el error"""
    err_rounded = float(f"{error:.1g}")
    decimals = -int(np.floor(np.log10(err_rounded)))
    val_rounded = round(value, decimals)
    err_rounded = round(err_rounded, decimals)
    return val_rounded, err_rounded

# -------------------------
# AJUSTE LINEAL (ponderado con error en Y)
# -------------------------
popt, pcov = curve_fit(f, corriente, theta, sigma=np.full_like(theta, dTheta), absolute_sigma=True)
m, b = popt
m_err, b_err = np.sqrt(np.diag(pcov))

# Redondeo formal
m_val, m_err = format_with_error(m, m_err)
b_val, b_err = format_with_error(b, b_err)

# R^2
resid = theta - f(corriente, m, b)
ss_res = np.sum(resid**2)
ss_tot = np.sum((theta - np.mean(theta))**2)
r2 = 1 - ss_res/ss_tot

# -------------------------
# GRÁFICAS
# -------------------------
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8, 8), sharex=True,
                               gridspec_kw={'height_ratios': [3, 1]})

# Principal
ax1.errorbar(corriente, theta, xerr=dI, yerr=dTheta, fmt="o", color="blue",
             ecolor="gray", capsize=3, label="Datos con error")
ax1.plot(corriente, f(corriente, m, b), "r-",
         label=(fr"Ajuste lineal:" "\n"
                fr"$\Delta \theta = ({m_val}\pm{m_err})I+({b_val}\pm{b_err})$"
                "\n"
                fr"$R^2={r2:.4f}$"))
ax1.legend()
ax1.set_ylabel(r"$\Delta \theta$ (rad)")
ax1.set_title("Δθ vs I")
ax1.grid(False)

# Residuos
ax2.errorbar(corriente, resid, fmt="o", color="black",
             ecolor="lightgray", capsize=3)
ax2.axhline(0, color="red", linestyle="--")
ax2.set_xlabel("Corriente (mA)")
ax2.set_ylabel("Residuos")
ax2.grid(False)

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# -----------------------
# 1. Datos experimentales
# -----------------------
f1 = np.array([700,720,740,760,780,800,820,840,860,880,900,920,940,960])
A1 = np.array([184,208,232,272,320,408,576,1000,2160,1120,640,416,312,264])

f2 = np.array([700,720,740,760,780,800,820,840,860,880,900,920,940,960])
A2 = np.array([180,196,228,264,312,392,520,720,940,780,540,400,304,248])

f3 = np.array([700,720,740,760,780,800,820,840,860,880,900])
A3 = np.array([173,192,216,244,280,320,376,424,440,416,368])

# Incertidumbres experimentales
df = 0.01   # Hz
dA = 0.01   # mV

# Convertir a frecuencia angular
w1, w2, w3 = 2*np.pi*f1, 2*np.pi*f2, 2*np.pi*f3

# -----------------------
# 2. Modelo teórico
# -----------------------
def A_model(w, A0, w0, gamma):
    return A0 / np.sqrt((w0**2 - w**2)**2 + (gamma*w)**2)

# -----------------------
# 3. Función para redondear con control de NaN
# -----------------------
def format_with_uncertainty(val, err):
    if np.isnan(err) or err == 0 or err is None:
        return f"{val:.3g} ± N/A"
    try:
        exp = int(np.floor(np.log10(abs(err))))
        err_rounded = round(err, -exp)
        val_rounded = round(val, -exp)
        return f"{val_rounded} ± {err_rounded}"
    except Exception:
        return f"{val:.3g} ± N/A"

# -----------------------
# 4. Ajuste con curva y residuos
# -----------------------
def fit_and_plot(w, A, f, label, color):
    # Estimaciones iniciales mejoradas
    A0_guess = max(A) * (max(w)**2)
    w0_guess = w[np.argmax(A)]
    gamma_guess = w0_guess / 10

    popt, pcov = curve_fit(A_model, w, A, p0=[A0_guess, w0_guess, gamma_guess],
                           sigma=np.ones_like(A)*dA, absolute_sigma=True,
                           maxfev=20000)

    A0_fit, w0_fit, gamma_fit = popt
    perr = np.sqrt(np.diag(pcov)) if pcov is not None else [np.nan, np.nan, np.nan]

    # Factor de calidad
    Q_fit = w0_fit / gamma_fit
    if np.isnan(perr[1]) or np.isnan(perr[2]):
        dQ = np.nan
    else:
        dQ = Q_fit * np.sqrt((perr[1]/w0_fit)**2 + (perr[2]/gamma_fit)**2)

    # Curva ajustada
    w_fit = np.linspace(min(w), max(w), 500)
    A_fit = A_model(w_fit, *popt)
    A_resid = A - A_model(w, *popt)

    # ---- Gráfico principal + residuos ----
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8,6),
                                   gridspec_kw={'height_ratios':[3,1]}, sharex=True)

    # Datos con barras de error
    ax1.errorbar(f, A, xerr=df, yerr=dA, fmt='o', color=color,
                 ecolor="gray", elinewidth=1, capsize=2, label="Datos exp.")
    ax1.plot(w_fit/(2*np.pi), A_fit, '--', color=color, label="Ajuste")

    ax1.set_ylabel("Amplitud (mV)")
    ax1.set_title(f"Curva de resonancia - {label}")
    ax1.legend()

    # Residuos
    ax2.axhline(0, color="black", linewidth=1)
    ax2.errorbar(f, A_resid, yerr=dA, fmt='o', color=color, ecolor="gray")
    ax2.set_xlabel("Frecuencia (Hz)")
    ax2.set_ylabel("Residuos")

    plt.tight_layout()
    plt.show()

    # ---- Resultados con incertidumbre ----
    print(f"\nResultados {label}:")
    print("A0   =", format_with_uncertainty(A0_fit, perr[0]))
    print("f0   =", format_with_uncertainty(w0_fit/(2*np.pi), perr[1]/(2*np.pi)), "Hz")
    print("gamma=", format_with_uncertainty(gamma_fit, perr[2]))
    print("Q    =", format_with_uncertainty(Q_fit, dQ))


# -----------------------
# 5. Ejecutar para los tres casos
# -----------------------
fit_and_plot(w1, A1, f1, "Caso 1", "red")
fit_and_plot(w2, A2, f2, "Caso 2", "blue")
fit_and_plot(w3, A3, f3, "Caso 3", "green")

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# -----------------------
# 1. Datos experimentales
# -----------------------
f1 = np.array([700,720,740,760,780,800,820,840,860,880,900,920,940,960])
A1 = np.array([184,208,232,272,320,408,576,1000,2160,1120,640,416,312,264])

f2 = np.array([700,720,740,760,780,800,820,840,860,880,900,920,940,960])
A2 = np.array([180,196,228,264,312,392,520,720,940,780,540,400,304,248])

f3 = np.array([700,720,740,760,780,800,820,840,860,880,900])
A3 = np.array([173,192,216,244,280,320,376,424,440,416,368])

# Incertidumbres experimentales
df = 0.01   # Hz
dA = 0.01   # mV

# Convertir a frecuencia angular (rad/s)
w1, w2, w3 = 2*np.pi*f1, 2*np.pi*f2, 2*np.pi*f3
dw = 2*np.pi*df  # incertidumbre en omega

# -----------------------
# 2. Modelo teórico
# -----------------------
def A_model(w, A0, w0, gamma):
    return A0 / np.sqrt((w0**2 - w**2)**2 + (gamma*w)**2)

# -----------------------
# 3. Función para redondear con control de NaN
# -----------------------
def format_with_uncertainty(val, err):
    if np.isnan(err) or err == 0 or err is None:
        return f"{val:.3g} ± N/A"
    try:
        exp = int(np.floor(np.log10(abs(err))))
        err_rounded = round(err, -exp)
        val_rounded = round(val, -exp)
        return f"{val_rounded} ± {err_rounded}"
    except Exception:
        return f"{val:.3g} ± N/A"

# -----------------------
# 4. Ajuste con curva y residuos
# -----------------------
def fit_and_plot(w, A, label, color):
    # Estimaciones iniciales
    A0_guess = max(A) * (max(w)**2)
    w0_guess = w[np.argmax(A)]
    gamma_guess = w0_guess / 10

    popt, pcov = curve_fit(A_model, w, A, p0=[A0_guess, w0_guess, gamma_guess],
                           sigma=np.ones_like(A)*dA, absolute_sigma=True,
                           maxfev=20000)

    A0_fit, w0_fit, gamma_fit = popt
    perr = np.sqrt(np.diag(pcov)) if pcov is not None else [np.nan, np.nan, np.nan]

    # Factor de calidad
    Q_fit = w0_fit / gamma_fit
    if np.isnan(perr[1]) or np.isnan(perr[2]):
        dQ = np.nan
    else:
        dQ = Q_fit * np.sqrt((perr[1]/w0_fit)**2 + (perr[2]/gamma_fit)**2)

    # Curva ajustada
    w_fit = np.linspace(min(w), max(w), 500)
    A_fit = A_model(w_fit, *popt)
    A_resid = A - A_model(w, *popt)

    # ---- Texto con resultados para la leyenda ----
    legend_text = (
        f"A0={format_with_uncertainty(A0_fit, perr[0])}\n"
        f"ω0={format_with_uncertainty(w0_fit, perr[1])} rad/s\n"
        f"γ={format_with_uncertainty(gamma_fit, perr[2])} rad/s\n"
        f"Q={format_with_uncertainty(Q_fit, dQ)}"
    )

    # ---- Gráfico principal + residuos ----
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8,6),
                                   gridspec_kw={'height_ratios':[3,1]}, sharex=True)

    # Datos con barras de error
    ax1.errorbar(w, A, xerr=dw, yerr=dA, fmt='o', color=color,
                 ecolor="gray", elinewidth=1, capsize=2, label="Datos exp.")
    ax1.plot(w_fit, A_fit, '--', color=color, label=legend_text)

    ax1.set_ylabel("Amplitud (mV)")
    ax1.set_title(f"Curva de resonancia - {label}")
    ax1.legend(loc="best", fontsize=8, frameon=False)

    # Residuos
    ax2.axhline(0, color="black", linewidth=1)
    ax2.errorbar(w, A_resid, yerr=dA, fmt='o', color=color, ecolor="gray")
    ax2.set_xlabel("ω (rad/s)")
    ax2.set_ylabel("Residuos")

    plt.tight_layout()
    plt.show()

    # ---- Resultados en consola también ----
    print(f"\nResultados {label}:")
    print("A0   =", format_with_uncertainty(A0_fit, perr[0]))
    print("ω0   =", format_with_uncertainty(w0_fit, perr[1]), "rad/s")
    print("gamma=", format_with_uncertainty(gamma_fit, perr[2]), "rad/s")
    print("Q    =", format_with_uncertainty(Q_fit, dQ))

# -----------------------
# 5. Ejecutar para los tres casos
# -----------------------
fit_and_plot(w1, A1, "Caso 1", "red")
fit_and_plot(w2, A2, "Caso 2", "blue")
fit_and_plot(w3, A3, "Caso 3", "green")